/*!
 * UserFilter for canvas
 * version: 0.1
 *
 * Copyright 2011, Y.Ushiki
 * released under the MIT license.
 *
 * git repository available at
 * https://github.com/youz/ufjs/
 */

class UserFilter
  ->
    # constants
    rmin = gmin = bmin = amin = cmin = 0
    rmax = gmax = bmax = amax = cmax = 255
    R = G = B = A = C = 255
    # var imin = 0, umin = -56, vmin = -78
    # imax = 255, umax = 56, vmax = 78
    xmin = ymin = mmin = dmin = 0
    D = 1024
    dmax = 1023
    Z = 4
    zmin = 0
    zmax = 3

    # canvas size
    X = xmax = Y = ymax = M = mmax = null

    # filter functions for each channel
    filters = new Array(4)

    # controler values (for ctl, val, map)
    ctls = [0 0 0 0 0 0 0 0]

    # filter functions
    ctl = (i) -> ctls[i]
    val = (i, a, b) -> a + ctls[i] * (b - a) / 255
    map = (i, n) ->
      if n <= ctls[2*i+1]
        0
      else if n >= ctls[2*i]
        255
      else if ctls[2*i+1] < n && n < ctls[2*i]
        (n - ctls[2*i+1]) * 255 / (ctls[2*i] - ctls[2*i+1])
      else
        0
  
    prev = []
    src = (x, y, z) ->
      if (0 <= x < X) && ( 0 <= y < Y)
        prev[(Math.floor(x) + Math.floor(y) * X) * 4 + z]
      else
        0

    rad = (d, m, z) -> src Math.floor(r2x(d, m)), Math.floor(r2y(d, m)), z

    _cnv = (x, y, z) ->
      (m11, m12, m13, m21, m22, m23, m31, m32, m33, d) ->
        (m11 * src(x-1, y-1, z) +
         m12 * src(x, y-1, z) +
         m13 * src(x+1, y-1, z) +
         m21 * src(x-1, y, z) +
         m22 * src(x, y, z) +
         m23 * src(x+1, y, z) +
         m31 * src(x-1, y+1, z) +
         m32 * src(x, y+1, z) +
         m33 * src(x+1, y+1, z)) / d

    min = Math.min
    max = Math.max
    abs = Math.abs

    add = (a, b, c) -> min(a + b, c)
    dif = (a, b)    -> abs(a - b)
    sub = (a, b, c) -> max(dif(a, b), c)

    rnd = (a, b) -> + Math.floor(Math.random() * (b - a + 1))
    mix = (a, b, n, d) -> if d == 0 then 0 else (a * n + b * (d - n)) / d

    scl = (a, il, ih, ol, oh) ->
      if a < il
        ol
      else if a > ih
        oh
      else if il == ih
        ol
      else
        ol + (a - il) * (oh - ol) / (ih - il)

    sqr = (x) -> if x < 0 then 0 else Math.sqrt x

    sintbl = (Math.sin(Math.PI * d / 512) * 1024 for d from 0 til 1024)
    sin = (x) -> sintbl[x & 1023]
    cos = (x) -> sintbl[(x + 256) & 1023]
    tan = (x) ->
      _cos = cos(x)
      if _cos == 0 then 0 else 1024 * sintbl[x & 1023] / _cos

    r2x = (d, m) -> m * cos(d) / 1024
    r2y = (d, m) -> m * sin(d) / 1024
    c2d = (x, y) ->
      dx = x - X/2
      dy = Y/2 - y
      Math.atan2(dy, dx) * 512 / Math.PI + if dy > 0 then 0 else 1024

    c2m = (x, y) ->
      dx = x - X/2
      dy = Y/2 - y
      Math.sqrt(dx * dx + dy * dy)

    temp = new Array(256)
    put = (v, i) -> if 0 <= i < 256 then temp[i >> 0] = v else 0
    get = (i) -> if 0 <= i < 256 then temp[i] else 0

    # additions
    PI = Math.PI
    rad2d = (rad) -> (rad * 512 / PI) & 1023
    deg2d = (deg) -> (deg * 1024 / 360) & 1023
    ceil = Math.ceil
    floor = Math.floor
    log = Math.log
    exp = Math.exp
    pow = Math.pow
  
    # for animation
    timer = null
    f = 0         # frame counter
    t = 0         # elapsed time from this.start() (msec)

    builtins = <[
      R r rmin rmax G g gmin gmax B b bmin bmax
      A a amin amax C c cmin cmax Z z zmin zmax
      X x xmin xmax Y y ymin ymax D d dmin dmax M m mmin mmax
      put get ctl val map src rad cnv min max abs add dif sub rnd mix scl
      sqr sin cos tan r2x r2y c2d c2m PI rad2d deg2d ceil floor log exp pow
      f t
      ]>

    user_functions = {}

    make_func = (formula) ->
      identifiers = builtins.slice(0)
      identifiers.push(k) for k in user_functions
      checker = new RegExp("^(#{identifiers * '|'}|)$")

      tokens = formula.split(/[\s,?:&|=!<>()*%+/~^-]+/)
      for w of tokens
        if (isNaN(tokens[i]) && !tokens[i].match(checker))
          throw "ILLEGAL TOKEN: '" + tokens[i] + "'"
      
      funcstr = "(function (x,y,m,d,r,g,b,a,c,z) { "
      if formula.match(/cnv/)
        funcstr += "var cnv = _cnv(x, y, z);"
      for name in user_functions
        if (typeof user_functions[name] == "string")
          funcstr += "var " + name + " = " + user_functions[name] + ";"
        else
          funcstr += "var " + name + " = user_functions['" + name + "'];"
      funcstr += " var _; _=" + formula + ";return _; })"
      eval(funcstr)

    apply_filter = (canvas) ->
      X = canvas.width
      Y = canvas.height
      xmax = X - 1
      ymax = Y - 1
      M = Math.floor(c2m(0, 0))
      mmax = M - 1

      ctx = canvas.getContext('2d')
      imagedata = ctx.getImageData(0, 0, X, Y)
      data = imagedata.data

      # for 'src' function
      prev = [].slice.call(data, 0)

      for y from 0 til Y
        offset = y << 2
        for x from 0 til X
          m = c2m(x, y)
          d = c2d(x, y)
          r = data[offset]
          g = data[offset+1]
          b = data[offset+2]
          a = data[offset+3]
          # i = (76*r + 150*g + 29*b) / 256
          # u = (-19*r - 37*g + 56*b) / 256
          # v = (78*r - 65*g - 13*b) / 256
          for z from 0 til 4
            try
              data[offset + z] = filters[z](x, y, m, d, r, g, b, a, data[offset + z], z)
            catch e
              throw "Error in formula: " + "RGBA"[z] + "\n" + e

      ctx.putImageData(imagedata, 0, 0)
      true

    if arguments.length == 4
      @setFormula ...
    else
      @setFormula "r", "g", "b", "a"


  ## public members
  setFormula: ->
    for i from 0 to 3
      try
        filters[i] = make_func(arguments[i])
      catch e
        throw "Error in formula: " + "RGBA"[i] + "\n" + e
    true
  
  controler: ctls
  apply: (elm) ->
    if elm.constructor == HTMLCanvasElement
      apply_filter(elm)
    else if elm.constructor == HTMLImageElement
      e = document.createElement('canvas')
      e.width = elm.width
      e.height = elm.height
      e.getContext('2d').drawImage(elm, 0, 0)
      result = apply_filter(e)
      if result
        elm.src = e.toDataURL()
      result
    else
      throw "filter can not apply to " + elm.toString()
  
  check: (formula) ->
    try
      make_func(formula)
      "ok"
    catch e
      e

  addFunction: (name, func) ->
    user_functions[name] = func
  
  ## animation
  reset_timer: -> f = 0
  start: (canvas, interval) ->
    clearInterval(timer)
    start_time = new Date
    f = 0
    fn = ->
      f++
      t = new Date - start_time
      if !apply_filter(canvas)
        clearInterval timer
    timer = setInterval fn, interval || 33
  
  stop: -> clearInterval(timer)
